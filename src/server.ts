import mongoose from 'mongoose';
import { app } from './app';
import { config } from './config';
import { logger } from './config/logger';
import http from 'http';
import chalk from 'chalk';
import { errorHandler } from './utils/errorHandler';


async function connectToDatabase(): Promise<void> {
  try {
    // Define mongoose connection options with proper typing
    const mongooseOptions: mongoose.ConnectOptions = {
      connectTimeoutMS: 10000,
      autoIndex: config.env === 'development',
      serverSelectionTimeoutMS: 5000,
      maxPoolSize: 10,
      minPoolSize: 2
    };

    await mongoose.connect(config.mongodb.uri, mongooseOptions);
    logger.info('Connected to MongoDB successfully');
  } catch (error) {
    logger.error({
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      uri: config.mongodb.uri.replace(/\/\/([^:]+):([^@]+)@/, '//******:******@')
    }, 'MongoDB connection error');
    process.exit(1);
  }
}

async function startServer(): Promise<void> {
  try {
    // Connect to MongoDB
    await connectToDatabase();
// await ProductModel.collection.dropIndex("variants.sku_1");
    // Register routes generated by TSOA
    try {
      // RegisterMobileRoutes(app);
      // RegisterAdminRoutes(app);
      // registerCategoryRoutes(app);
      // logger.info('TSOA routes registered successfully');
    } catch (error) {
      logger.error({
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      }, 'Failed to register TSOA routes');
      throw error;
    }

    // 404 handler - after all routes are registered
    app.use((_req, res) => {
      res.status(404).json({
        error: {
          code: 'NOT_FOUND',
          message: 'Resource not found'
        }
      });
    });

    // Global error handler - must be last
    app.use(errorHandler);

    // Start the server with proper typing
    const server: http.Server = app.listen(config.port, () => {
      logger.info({
        env: config.env,
        port: config.port,
        nodeVersion: process.version,
        memoryUsage: Math.round(process.memoryUsage().rss / (1024 * 1024)) + 'MB'
      }, `Server started - ${config.env} mode on port ${config.port}`);
console.log(chalk.bold.green(`Server is running on port ${config.port}`));
      // Log available endpoints
      const baseUrl = `http://localhost:${config.port}/v1`;
      console.log(chalk.bold.green(`http://localhost:${config.port}/docs`));
     
    
      logger.info(`Mobile API: ${baseUrl}/mobile`);
      logger.info(`Admin API: ${baseUrl}/admin`);
      logger.info(`Mobile Docs: ${baseUrl}/mobile/docs`);
      logger.info(`Admin Docs: ${baseUrl}/admin/docs`); // Fixed the typo here


      console.log(`\nðŸš€ Server is running on port ${config.port}`);
      console.log(`ðŸ“‹ Admin API Docs: http://localhost:${config.port}/v1/admin/docs`);
      console.log(`ðŸ“± Mobile API Docs: http://localhost:${config.port}/v1/mobile/docs`);
      console.log(`ðŸ’Š Health Check: http://localhost:${config.port}/health`);
    });

    // Define types for shutdown handlers
    const gracefulShutdown = (signal: string): void => {
      logger.info(`${signal} received, shutting down gracefully`);
      server.close(() => {
        logger.info('HTTP server closed');
        mongoose.connection.close(false)
          .then(() => {
            logger.info('MongoDB connection closed');
            process.exit(0);
          })
          .catch((err) => {
            logger.error({ error: err }, 'Error during MongoDB connection close');
            process.exit(1);
          });
      });

      // Force shutdown after 10s if graceful shutdown fails
      setTimeout(() => {
        logger.error('Forcing shutdown after timeout');
        process.exit(1);
      }, 10000);
    };

    // Set up signal handlers for different termination signals
    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));

  } catch (error) {
    logger.error({
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined
    }, 'Failed to start server');
    process.exit(1);
  }
}

// Start the server
startServer().catch((error) => {
  console.error('Unhandled server startup error:', error);
  process.exit(1);
});